// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: wakatime_queries.sql

package wakatime_db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDay = `-- name: CreateDay :one

INSERT INTO wakatime_days (user_id, date, total_seconds, text)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, date, total_seconds, text, created_at, updated_at
`

type CreateDayParams struct {
	UserID       pgtype.UUID
	Date         pgtype.Date
	TotalSeconds float64
	Text         pgtype.Text
}

// Дни -------------------------------------------------------------------
func (q *Queries) CreateDay(ctx context.Context, arg CreateDayParams) (WakatimeDay, error) {
	row := q.db.QueryRow(ctx, createDay,
		arg.UserID,
		arg.Date,
		arg.TotalSeconds,
		arg.Text,
	)
	var i WakatimeDay
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.TotalSeconds,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDependency = `-- name: CreateDependency :one

INSERT INTO wakatime_dependencies (day_id, name, total_seconds, percent, text)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, day_id, name, total_seconds, percent, text, created_at
`

type CreateDependencyParams struct {
	DayID        int32
	Name         string
	TotalSeconds float64
	Percent      pgtype.Float8
	Text         pgtype.Text
}

// Зависимости -------------------------------------------------------------------
func (q *Queries) CreateDependency(ctx context.Context, arg CreateDependencyParams) (WakatimeDependency, error) {
	row := q.db.QueryRow(ctx, createDependency,
		arg.DayID,
		arg.Name,
		arg.TotalSeconds,
		arg.Percent,
		arg.Text,
	)
	var i WakatimeDependency
	err := row.Scan(
		&i.ID,
		&i.DayID,
		&i.Name,
		&i.TotalSeconds,
		&i.Percent,
		&i.Text,
		&i.CreatedAt,
	)
	return i, err
}

const createEditor = `-- name: CreateEditor :one

INSERT INTO wakatime_editors (day_id, name, total_seconds, percent, text)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, day_id, name, total_seconds, percent, text, created_at
`

type CreateEditorParams struct {
	DayID        int32
	Name         string
	TotalSeconds float64
	Percent      pgtype.Float8
	Text         pgtype.Text
}

// Редакторы -------------------------------------------------------------------
func (q *Queries) CreateEditor(ctx context.Context, arg CreateEditorParams) (WakatimeEditor, error) {
	row := q.db.QueryRow(ctx, createEditor,
		arg.DayID,
		arg.Name,
		arg.TotalSeconds,
		arg.Percent,
		arg.Text,
	)
	var i WakatimeEditor
	err := row.Scan(
		&i.ID,
		&i.DayID,
		&i.Name,
		&i.TotalSeconds,
		&i.Percent,
		&i.Text,
		&i.CreatedAt,
	)
	return i, err
}

const createLanguage = `-- name: CreateLanguage :one

INSERT INTO wakatime_languages (day_id, name, total_seconds, percent, text)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, day_id, name, total_seconds, percent, text, created_at
`

type CreateLanguageParams struct {
	DayID        int32
	Name         string
	TotalSeconds float64
	Percent      pgtype.Float8
	Text         pgtype.Text
}

// Языки -------------------------------------------------------------------
func (q *Queries) CreateLanguage(ctx context.Context, arg CreateLanguageParams) (WakatimeLanguage, error) {
	row := q.db.QueryRow(ctx, createLanguage,
		arg.DayID,
		arg.Name,
		arg.TotalSeconds,
		arg.Percent,
		arg.Text,
	)
	var i WakatimeLanguage
	err := row.Scan(
		&i.ID,
		&i.DayID,
		&i.Name,
		&i.TotalSeconds,
		&i.Percent,
		&i.Text,
		&i.CreatedAt,
	)
	return i, err
}

const createMachine = `-- name: CreateMachine :one

INSERT INTO wakatime_machines (day_id, name, total_seconds, percent, text)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, day_id, name, total_seconds, percent, text, created_at
`

type CreateMachineParams struct {
	DayID        int32
	Name         string
	TotalSeconds float64
	Percent      pgtype.Float8
	Text         pgtype.Text
}

// Машины -------------------------------------------------------------------
func (q *Queries) CreateMachine(ctx context.Context, arg CreateMachineParams) (WakatimeMachine, error) {
	row := q.db.QueryRow(ctx, createMachine,
		arg.DayID,
		arg.Name,
		arg.TotalSeconds,
		arg.Percent,
		arg.Text,
	)
	var i WakatimeMachine
	err := row.Scan(
		&i.ID,
		&i.DayID,
		&i.Name,
		&i.TotalSeconds,
		&i.Percent,
		&i.Text,
		&i.CreatedAt,
	)
	return i, err
}

const createOS = `-- name: CreateOS :one

INSERT INTO wakatime_os (day_id, name, total_seconds, percent, text)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, day_id, name, total_seconds, percent, text, created_at
`

type CreateOSParams struct {
	DayID        int32
	Name         string
	TotalSeconds float64
	Percent      pgtype.Float8
	Text         pgtype.Text
}

// ОС -------------------------------------------------------------------
func (q *Queries) CreateOS(ctx context.Context, arg CreateOSParams) (WakatimeO, error) {
	row := q.db.QueryRow(ctx, createOS,
		arg.DayID,
		arg.Name,
		arg.TotalSeconds,
		arg.Percent,
		arg.Text,
	)
	var i WakatimeO
	err := row.Scan(
		&i.ID,
		&i.DayID,
		&i.Name,
		&i.TotalSeconds,
		&i.Percent,
		&i.Text,
		&i.CreatedAt,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one

INSERT INTO wakatime_projects (day_id, name, total_seconds, percent, text)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, day_id, name, total_seconds, percent, text, created_at
`

type CreateProjectParams struct {
	DayID        int32
	Name         string
	TotalSeconds float64
	Percent      pgtype.Float8
	Text         pgtype.Text
}

// Проекты -------------------------------------------------------------------
func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (WakatimeProject, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.DayID,
		arg.Name,
		arg.TotalSeconds,
		arg.Percent,
		arg.Text,
	)
	var i WakatimeProject
	err := row.Scan(
		&i.ID,
		&i.DayID,
		&i.Name,
		&i.TotalSeconds,
		&i.Percent,
		&i.Text,
		&i.CreatedAt,
	)
	return i, err
}

const createSummary = `-- name: CreateSummary :one

INSERT INTO wakatime_summaries (user_id, start_time, end_time, range, total_seconds, daily_average, best_day_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, start_time, end_time, range, total_seconds, daily_average, best_day_id, created_at
`

type CreateSummaryParams struct {
	UserID       pgtype.UUID
	StartTime    pgtype.Timestamptz
	EndTime      pgtype.Timestamptz
	Range        pgtype.Text
	TotalSeconds pgtype.Float8
	DailyAverage pgtype.Float8
	BestDayID    pgtype.Int4
}

// Сводная статистика -------------------------------------------------------------------
func (q *Queries) CreateSummary(ctx context.Context, arg CreateSummaryParams) (WakatimeSummary, error) {
	row := q.db.QueryRow(ctx, createSummary,
		arg.UserID,
		arg.StartTime,
		arg.EndTime,
		arg.Range,
		arg.TotalSeconds,
		arg.DailyAverage,
		arg.BestDayID,
	)
	var i WakatimeSummary
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StartTime,
		&i.EndTime,
		&i.Range,
		&i.TotalSeconds,
		&i.DailyAverage,
		&i.BestDayID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteDay = `-- name: DeleteDay :exec
DELETE FROM wakatime_days WHERE id = $1
`

func (q *Queries) DeleteDay(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteDay, id)
	return err
}

const deleteDependenciesByDay = `-- name: DeleteDependenciesByDay :exec
DELETE FROM wakatime_dependencies WHERE day_id = $1
`

func (q *Queries) DeleteDependenciesByDay(ctx context.Context, dayID int32) error {
	_, err := q.db.Exec(ctx, deleteDependenciesByDay, dayID)
	return err
}

const deleteDependency = `-- name: DeleteDependency :exec
DELETE FROM wakatime_dependencies WHERE id = $1
`

func (q *Queries) DeleteDependency(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteDependency, id)
	return err
}

const deleteEditor = `-- name: DeleteEditor :exec
DELETE FROM wakatime_editors WHERE id = $1
`

func (q *Queries) DeleteEditor(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteEditor, id)
	return err
}

const deleteEditorsByDay = `-- name: DeleteEditorsByDay :exec
DELETE FROM wakatime_editors WHERE day_id = $1
`

func (q *Queries) DeleteEditorsByDay(ctx context.Context, dayID int32) error {
	_, err := q.db.Exec(ctx, deleteEditorsByDay, dayID)
	return err
}

const deleteLanguage = `-- name: DeleteLanguage :exec
DELETE FROM wakatime_languages WHERE id = $1
`

func (q *Queries) DeleteLanguage(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteLanguage, id)
	return err
}

const deleteLanguagesByDay = `-- name: DeleteLanguagesByDay :exec
DELETE FROM wakatime_languages WHERE day_id = $1
`

func (q *Queries) DeleteLanguagesByDay(ctx context.Context, dayID int32) error {
	_, err := q.db.Exec(ctx, deleteLanguagesByDay, dayID)
	return err
}

const deleteMachine = `-- name: DeleteMachine :exec
DELETE FROM wakatime_machines WHERE id = $1
`

func (q *Queries) DeleteMachine(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteMachine, id)
	return err
}

const deleteMachinesByDay = `-- name: DeleteMachinesByDay :exec
DELETE FROM wakatime_machines WHERE day_id = $1
`

func (q *Queries) DeleteMachinesByDay(ctx context.Context, dayID int32) error {
	_, err := q.db.Exec(ctx, deleteMachinesByDay, dayID)
	return err
}

const deleteOS = `-- name: DeleteOS :exec
DELETE FROM wakatime_os WHERE id = $1
`

func (q *Queries) DeleteOS(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteOS, id)
	return err
}

const deleteOSByDay = `-- name: DeleteOSByDay :exec
DELETE FROM wakatime_os WHERE day_id = $1
`

func (q *Queries) DeleteOSByDay(ctx context.Context, dayID int32) error {
	_, err := q.db.Exec(ctx, deleteOSByDay, dayID)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM wakatime_projects WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const deleteProjectsByDay = `-- name: DeleteProjectsByDay :exec
DELETE FROM wakatime_projects WHERE day_id = $1
`

func (q *Queries) DeleteProjectsByDay(ctx context.Context, dayID int32) error {
	_, err := q.db.Exec(ctx, deleteProjectsByDay, dayID)
	return err
}

const deleteSummary = `-- name: DeleteSummary :exec
DELETE FROM wakatime_summaries WHERE id = $1
`

func (q *Queries) DeleteSummary(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteSummary, id)
	return err
}

const getDayByDate = `-- name: GetDayByDate :one
SELECT id, user_id, date, total_seconds, text, created_at, updated_at FROM wakatime_days WHERE user_id = $1 AND date = $2
`

type GetDayByDateParams struct {
	UserID pgtype.UUID
	Date   pgtype.Date
}

func (q *Queries) GetDayByDate(ctx context.Context, arg GetDayByDateParams) (WakatimeDay, error) {
	row := q.db.QueryRow(ctx, getDayByDate, arg.UserID, arg.Date)
	var i WakatimeDay
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.TotalSeconds,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDayByID = `-- name: GetDayByID :one
SELECT id, user_id, date, total_seconds, text, created_at, updated_at FROM wakatime_days WHERE id = $1
`

func (q *Queries) GetDayByID(ctx context.Context, id int32) (WakatimeDay, error) {
	row := q.db.QueryRow(ctx, getDayByID, id)
	var i WakatimeDay
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.TotalSeconds,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDaysByDateRange = `-- name: GetDaysByDateRange :many
SELECT id, user_id, date, total_seconds, text, created_at, updated_at FROM wakatime_days
WHERE user_id = $1 AND date BETWEEN $2 AND $3
ORDER BY date DESC
`

type GetDaysByDateRangeParams struct {
	UserID pgtype.UUID
	Date   pgtype.Date
	Date_2 pgtype.Date
}

func (q *Queries) GetDaysByDateRange(ctx context.Context, arg GetDaysByDateRangeParams) ([]WakatimeDay, error) {
	rows, err := q.db.Query(ctx, getDaysByDateRange, arg.UserID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WakatimeDay
	for rows.Next() {
		var i WakatimeDay
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Date,
			&i.TotalSeconds,
			&i.Text,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, day_id, name, total_seconds, percent, text, created_at FROM wakatime_projects WHERE id = $1
`

func (q *Queries) GetProjectByID(ctx context.Context, id int32) (WakatimeProject, error) {
	row := q.db.QueryRow(ctx, getProjectByID, id)
	var i WakatimeProject
	err := row.Scan(
		&i.ID,
		&i.DayID,
		&i.Name,
		&i.TotalSeconds,
		&i.Percent,
		&i.Text,
		&i.CreatedAt,
	)
	return i, err
}

const getSummaryByID = `-- name: GetSummaryByID :one
SELECT id, user_id, start_time, end_time, range, total_seconds, daily_average, best_day_id, created_at FROM wakatime_summaries WHERE id = $1
`

func (q *Queries) GetSummaryByID(ctx context.Context, id int32) (WakatimeSummary, error) {
	row := q.db.QueryRow(ctx, getSummaryByID, id)
	var i WakatimeSummary
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StartTime,
		&i.EndTime,
		&i.Range,
		&i.TotalSeconds,
		&i.DailyAverage,
		&i.BestDayID,
		&i.CreatedAt,
	)
	return i, err
}

const getWakatimeStatsByDateRange = `-- name: GetWakatimeStatsByDateRange :many
SELECT
    d.id as day_id,
    d.date,
    d.total_seconds,
    d.text as day_text,
    p.name as project_name,
    p.total_seconds as project_seconds,
    l.name as language_name,
    l.total_seconds as language_seconds
FROM
    wakatime_days d
        LEFT JOIN
    wakatime_projects p ON d.id = p.day_id
        LEFT JOIN
    wakatime_languages l ON d.id = l.day_id
WHERE
    d.user_id = $1
  AND d.date >= $2
  AND d.date <= $3
ORDER BY
    d.date DESC, p.total_seconds DESC, l.total_seconds DESC
`

type GetWakatimeStatsByDateRangeParams struct {
	UserID pgtype.UUID
	Date   pgtype.Date
	Date_2 pgtype.Date
}

type GetWakatimeStatsByDateRangeRow struct {
	DayID           int32
	Date            pgtype.Date
	TotalSeconds    float64
	DayText         pgtype.Text
	ProjectName     pgtype.Text
	ProjectSeconds  pgtype.Float8
	LanguageName    pgtype.Text
	LanguageSeconds pgtype.Float8
}

func (q *Queries) GetWakatimeStatsByDateRange(ctx context.Context, arg GetWakatimeStatsByDateRangeParams) ([]GetWakatimeStatsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getWakatimeStatsByDateRange, arg.UserID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWakatimeStatsByDateRangeRow
	for rows.Next() {
		var i GetWakatimeStatsByDateRangeRow
		if err := rows.Scan(
			&i.DayID,
			&i.Date,
			&i.TotalSeconds,
			&i.DayText,
			&i.ProjectName,
			&i.ProjectSeconds,
			&i.LanguageName,
			&i.LanguageSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDaysByUser = `-- name: ListDaysByUser :many
SELECT id, user_id, date, total_seconds, text, created_at, updated_at FROM wakatime_days WHERE user_id = $1 ORDER BY date DESC
`

func (q *Queries) ListDaysByUser(ctx context.Context, userID pgtype.UUID) ([]WakatimeDay, error) {
	rows, err := q.db.Query(ctx, listDaysByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WakatimeDay
	for rows.Next() {
		var i WakatimeDay
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Date,
			&i.TotalSeconds,
			&i.Text,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDependenciesByDay = `-- name: ListDependenciesByDay :many
SELECT id, day_id, name, total_seconds, percent, text, created_at FROM wakatime_dependencies WHERE day_id = $1 ORDER BY total_seconds DESC
`

func (q *Queries) ListDependenciesByDay(ctx context.Context, dayID int32) ([]WakatimeDependency, error) {
	rows, err := q.db.Query(ctx, listDependenciesByDay, dayID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WakatimeDependency
	for rows.Next() {
		var i WakatimeDependency
		if err := rows.Scan(
			&i.ID,
			&i.DayID,
			&i.Name,
			&i.TotalSeconds,
			&i.Percent,
			&i.Text,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEditorsByDay = `-- name: ListEditorsByDay :many
SELECT id, day_id, name, total_seconds, percent, text, created_at FROM wakatime_editors WHERE day_id = $1 ORDER BY total_seconds DESC
`

func (q *Queries) ListEditorsByDay(ctx context.Context, dayID int32) ([]WakatimeEditor, error) {
	rows, err := q.db.Query(ctx, listEditorsByDay, dayID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WakatimeEditor
	for rows.Next() {
		var i WakatimeEditor
		if err := rows.Scan(
			&i.ID,
			&i.DayID,
			&i.Name,
			&i.TotalSeconds,
			&i.Percent,
			&i.Text,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLanguagesByDay = `-- name: ListLanguagesByDay :many
SELECT id, day_id, name, total_seconds, percent, text, created_at FROM wakatime_languages WHERE day_id = $1 ORDER BY total_seconds DESC
`

func (q *Queries) ListLanguagesByDay(ctx context.Context, dayID int32) ([]WakatimeLanguage, error) {
	rows, err := q.db.Query(ctx, listLanguagesByDay, dayID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WakatimeLanguage
	for rows.Next() {
		var i WakatimeLanguage
		if err := rows.Scan(
			&i.ID,
			&i.DayID,
			&i.Name,
			&i.TotalSeconds,
			&i.Percent,
			&i.Text,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMachinesByDay = `-- name: ListMachinesByDay :many
SELECT id, day_id, name, total_seconds, percent, text, created_at FROM wakatime_machines WHERE day_id = $1 ORDER BY total_seconds DESC
`

func (q *Queries) ListMachinesByDay(ctx context.Context, dayID int32) ([]WakatimeMachine, error) {
	rows, err := q.db.Query(ctx, listMachinesByDay, dayID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WakatimeMachine
	for rows.Next() {
		var i WakatimeMachine
		if err := rows.Scan(
			&i.ID,
			&i.DayID,
			&i.Name,
			&i.TotalSeconds,
			&i.Percent,
			&i.Text,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOSByDay = `-- name: ListOSByDay :many
SELECT id, day_id, name, total_seconds, percent, text, created_at FROM wakatime_os WHERE day_id = $1 ORDER BY total_seconds DESC
`

func (q *Queries) ListOSByDay(ctx context.Context, dayID int32) ([]WakatimeO, error) {
	rows, err := q.db.Query(ctx, listOSByDay, dayID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WakatimeO
	for rows.Next() {
		var i WakatimeO
		if err := rows.Scan(
			&i.ID,
			&i.DayID,
			&i.Name,
			&i.TotalSeconds,
			&i.Percent,
			&i.Text,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsByDay = `-- name: ListProjectsByDay :many
SELECT id, day_id, name, total_seconds, percent, text, created_at FROM wakatime_projects WHERE day_id = $1 ORDER BY total_seconds DESC
`

func (q *Queries) ListProjectsByDay(ctx context.Context, dayID int32) ([]WakatimeProject, error) {
	rows, err := q.db.Query(ctx, listProjectsByDay, dayID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WakatimeProject
	for rows.Next() {
		var i WakatimeProject
		if err := rows.Scan(
			&i.ID,
			&i.DayID,
			&i.Name,
			&i.TotalSeconds,
			&i.Percent,
			&i.Text,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSummariesByUser = `-- name: ListSummariesByUser :many
SELECT id, user_id, start_time, end_time, range, total_seconds, daily_average, best_day_id, created_at FROM wakatime_summaries WHERE user_id = $1 ORDER BY start_time DESC
`

func (q *Queries) ListSummariesByUser(ctx context.Context, userID pgtype.UUID) ([]WakatimeSummary, error) {
	rows, err := q.db.Query(ctx, listSummariesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WakatimeSummary
	for rows.Next() {
		var i WakatimeSummary
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StartTime,
			&i.EndTime,
			&i.Range,
			&i.TotalSeconds,
			&i.DailyAverage,
			&i.BestDayID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDay = `-- name: UpdateDay :one
UPDATE wakatime_days
SET total_seconds = $2, text = $3, updated_at = now()
WHERE id = $1
RETURNING id, user_id, date, total_seconds, text, created_at, updated_at
`

type UpdateDayParams struct {
	ID           int32
	TotalSeconds float64
	Text         pgtype.Text
}

func (q *Queries) UpdateDay(ctx context.Context, arg UpdateDayParams) (WakatimeDay, error) {
	row := q.db.QueryRow(ctx, updateDay, arg.ID, arg.TotalSeconds, arg.Text)
	var i WakatimeDay
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.TotalSeconds,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE wakatime_projects
SET total_seconds = $2, percent = $3, text = $4
WHERE id = $1
RETURNING id, day_id, name, total_seconds, percent, text, created_at
`

type UpdateProjectParams struct {
	ID           int32
	TotalSeconds float64
	Percent      pgtype.Float8
	Text         pgtype.Text
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (WakatimeProject, error) {
	row := q.db.QueryRow(ctx, updateProject,
		arg.ID,
		arg.TotalSeconds,
		arg.Percent,
		arg.Text,
	)
	var i WakatimeProject
	err := row.Scan(
		&i.ID,
		&i.DayID,
		&i.Name,
		&i.TotalSeconds,
		&i.Percent,
		&i.Text,
		&i.CreatedAt,
	)
	return i, err
}
