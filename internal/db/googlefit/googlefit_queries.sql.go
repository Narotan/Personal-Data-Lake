// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: googlefit_queries.sql

package googlefit_db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDailyStat = `-- name: CreateDailyStat :one

INSERT INTO googlefit_daily_stats (user_id, date, steps, distance)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, date, steps, distance, created_at, updated_at
`

type CreateDailyStatParams struct {
	UserID   pgtype.UUID
	Date     pgtype.Date
	Steps    pgtype.Int4
	Distance pgtype.Float8
}

// Daily Stats Queries -------------------------------------------------------------------
func (q *Queries) CreateDailyStat(ctx context.Context, arg CreateDailyStatParams) (GooglefitDailyStat, error) {
	row := q.db.QueryRow(ctx, createDailyStat,
		arg.UserID,
		arg.Date,
		arg.Steps,
		arg.Distance,
	)
	var i GooglefitDailyStat
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Steps,
		&i.Distance,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDailyStat = `-- name: DeleteDailyStat :exec
DELETE FROM googlefit_daily_stats WHERE id = $1
`

func (q *Queries) DeleteDailyStat(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteDailyStat, id)
	return err
}

const getDailyStatByDate = `-- name: GetDailyStatByDate :one
SELECT id, user_id, date, steps, distance, created_at, updated_at FROM googlefit_daily_stats WHERE user_id = $1 AND date = $2
`

type GetDailyStatByDateParams struct {
	UserID pgtype.UUID
	Date   pgtype.Date
}

func (q *Queries) GetDailyStatByDate(ctx context.Context, arg GetDailyStatByDateParams) (GooglefitDailyStat, error) {
	row := q.db.QueryRow(ctx, getDailyStatByDate, arg.UserID, arg.Date)
	var i GooglefitDailyStat
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Steps,
		&i.Distance,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGoogleFitDailyStatsByDateRange = `-- name: GetGoogleFitDailyStatsByDateRange :many
SELECT
    date,
    steps,
    distance
FROM
    googlefit_daily_stats
WHERE
    user_id = $1
  AND date >= $2
  AND date <= $3
ORDER BY
    date DESC
`

type GetGoogleFitDailyStatsByDateRangeParams struct {
	UserID pgtype.UUID
	Date   pgtype.Date
	Date_2 pgtype.Date
}

type GetGoogleFitDailyStatsByDateRangeRow struct {
	Date     pgtype.Date
	Steps    pgtype.Int4
	Distance pgtype.Float8
}

func (q *Queries) GetGoogleFitDailyStatsByDateRange(ctx context.Context, arg GetGoogleFitDailyStatsByDateRangeParams) ([]GetGoogleFitDailyStatsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getGoogleFitDailyStatsByDateRange, arg.UserID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGoogleFitDailyStatsByDateRangeRow
	for rows.Next() {
		var i GetGoogleFitDailyStatsByDateRangeRow
		if err := rows.Scan(&i.Date, &i.Steps, &i.Distance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyAverage = `-- name: GetMonthlyAverage :one
SELECT
    AVG(steps) as avg_steps,
    AVG(distance) as avg_distance,
    SUM(steps) as total_steps,
    SUM(distance) as total_distance
FROM googlefit_daily_stats
WHERE user_id = $1
  AND date >= CURRENT_DATE - INTERVAL '30 days'
`

type GetMonthlyAverageRow struct {
	AvgSteps      float64
	AvgDistance   float64
	TotalSteps    int64
	TotalDistance int64
}

func (q *Queries) GetMonthlyAverage(ctx context.Context, userID pgtype.UUID) (GetMonthlyAverageRow, error) {
	row := q.db.QueryRow(ctx, getMonthlyAverage, userID)
	var i GetMonthlyAverageRow
	err := row.Scan(
		&i.AvgSteps,
		&i.AvgDistance,
		&i.TotalSteps,
		&i.TotalDistance,
	)
	return i, err
}

const getWeeklyStepsSummary = `-- name: GetWeeklyStepsSummary :many

SELECT
    date,
    steps,
    distance,
    EXTRACT(DOW FROM date) as day_of_week
FROM googlefit_daily_stats
WHERE user_id = $1
  AND date >= CURRENT_DATE - INTERVAL '7 days'
ORDER BY date DESC
`

type GetWeeklyStepsSummaryRow struct {
	Date      pgtype.Date
	Steps     pgtype.Int4
	Distance  pgtype.Float8
	DayOfWeek pgtype.Numeric
}

// Analytics Queries -------------------------------------------------------------------
func (q *Queries) GetWeeklyStepsSummary(ctx context.Context, userID pgtype.UUID) ([]GetWeeklyStepsSummaryRow, error) {
	rows, err := q.db.Query(ctx, getWeeklyStepsSummary, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWeeklyStepsSummaryRow
	for rows.Next() {
		var i GetWeeklyStepsSummaryRow
		if err := rows.Scan(
			&i.Date,
			&i.Steps,
			&i.Distance,
			&i.DayOfWeek,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDailyStatsByDateRange = `-- name: ListDailyStatsByDateRange :many
SELECT id, user_id, date, steps, distance, created_at, updated_at FROM googlefit_daily_stats
WHERE user_id = $1 AND date BETWEEN $2 AND $3
ORDER BY date DESC
`

type ListDailyStatsByDateRangeParams struct {
	UserID pgtype.UUID
	Date   pgtype.Date
	Date_2 pgtype.Date
}

func (q *Queries) ListDailyStatsByDateRange(ctx context.Context, arg ListDailyStatsByDateRangeParams) ([]GooglefitDailyStat, error) {
	rows, err := q.db.Query(ctx, listDailyStatsByDateRange, arg.UserID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GooglefitDailyStat
	for rows.Next() {
		var i GooglefitDailyStat
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Date,
			&i.Steps,
			&i.Distance,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDailyStatsByUser = `-- name: ListDailyStatsByUser :many
SELECT id, user_id, date, steps, distance, created_at, updated_at FROM googlefit_daily_stats
WHERE user_id = $1
ORDER BY date DESC
LIMIT $2 OFFSET $3
`

type ListDailyStatsByUserParams struct {
	UserID pgtype.UUID
	Limit  int32
	Offset int32
}

func (q *Queries) ListDailyStatsByUser(ctx context.Context, arg ListDailyStatsByUserParams) ([]GooglefitDailyStat, error) {
	rows, err := q.db.Query(ctx, listDailyStatsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GooglefitDailyStat
	for rows.Next() {
		var i GooglefitDailyStat
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Date,
			&i.Steps,
			&i.Distance,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDailyStat = `-- name: UpdateDailyStat :one
UPDATE googlefit_daily_stats
SET steps = $2, distance = $3, updated_at = now()
WHERE id = $1
RETURNING id, user_id, date, steps, distance, created_at, updated_at
`

type UpdateDailyStatParams struct {
	ID       int32
	Steps    pgtype.Int4
	Distance pgtype.Float8
}

func (q *Queries) UpdateDailyStat(ctx context.Context, arg UpdateDailyStatParams) (GooglefitDailyStat, error) {
	row := q.db.QueryRow(ctx, updateDailyStat, arg.ID, arg.Steps, arg.Distance)
	var i GooglefitDailyStat
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Steps,
		&i.Distance,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertDailyStat = `-- name: UpsertDailyStat :one
INSERT INTO googlefit_daily_stats (user_id, date, steps, distance)
VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id, date)
DO UPDATE SET
    steps = EXCLUDED.steps,
    distance = EXCLUDED.distance,
    updated_at = now()
RETURNING id, user_id, date, steps, distance, created_at, updated_at
`

type UpsertDailyStatParams struct {
	UserID   pgtype.UUID
	Date     pgtype.Date
	Steps    pgtype.Int4
	Distance pgtype.Float8
}

func (q *Queries) UpsertDailyStat(ctx context.Context, arg UpsertDailyStatParams) (GooglefitDailyStat, error) {
	row := q.db.QueryRow(ctx, upsertDailyStat,
		arg.UserID,
		arg.Date,
		arg.Steps,
		arg.Distance,
	)
	var i GooglefitDailyStat
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Steps,
		&i.Distance,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
