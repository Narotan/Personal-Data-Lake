// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: activitywatch_queries.sql

package activitywatch_db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkInsertEventsParams struct {
	Timestamp pgtype.Timestamptz
	Duration  float64
	App       string
	Title     pgtype.Text
	BucketID  string
}

const getAppStats = `-- name: GetAppStats :many
SELECT
    app,
    SUM(duration)::float as total_duration,
    COUNT(*) as event_count
FROM activity_events
WHERE timestamp >= $1 AND timestamp < $2
GROUP BY app
ORDER BY total_duration DESC
`

type GetAppStatsParams struct {
	Timestamp   pgtype.Timestamptz
	Timestamp_2 pgtype.Timestamptz
}

type GetAppStatsRow struct {
	App           string
	TotalDuration float64
	EventCount    int64
}

func (q *Queries) GetAppStats(ctx context.Context, arg GetAppStatsParams) ([]GetAppStatsRow, error) {
	rows, err := q.db.Query(ctx, getAppStats, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAppStatsRow
	for rows.Next() {
		var i GetAppStatsRow
		if err := rows.Scan(&i.App, &i.TotalDuration, &i.EventCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByApp = `-- name: GetEventsByApp :many
SELECT id, timestamp, duration, app, title, bucket_id, created_at FROM activity_events
WHERE app = $1 AND timestamp >= $2 AND timestamp < $3
ORDER BY timestamp DESC
`

type GetEventsByAppParams struct {
	App         string
	Timestamp   pgtype.Timestamptz
	Timestamp_2 pgtype.Timestamptz
}

func (q *Queries) GetEventsByApp(ctx context.Context, arg GetEventsByAppParams) ([]ActivityEvent, error) {
	rows, err := q.db.Query(ctx, getEventsByApp, arg.App, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActivityEvent
	for rows.Next() {
		var i ActivityEvent
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.Duration,
			&i.App,
			&i.Title,
			&i.BucketID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentEvents = `-- name: GetRecentEvents :many
SELECT id, timestamp, duration, app, title, bucket_id, created_at FROM activity_events
WHERE timestamp >= $1
ORDER BY timestamp DESC
LIMIT $2
`

type GetRecentEventsParams struct {
	Timestamp pgtype.Timestamptz
	Limit     int32
}

func (q *Queries) GetRecentEvents(ctx context.Context, arg GetRecentEventsParams) ([]ActivityEvent, error) {
	rows, err := q.db.Query(ctx, getRecentEvents, arg.Timestamp, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActivityEvent
	for rows.Next() {
		var i ActivityEvent
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.Duration,
			&i.App,
			&i.Title,
			&i.BucketID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
